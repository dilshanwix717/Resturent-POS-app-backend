import User from "../models/user.model.js";
import bcrypt from "bcrypt";
import FinishedGoodTransaction from "../models/finishedgood_transaction.model.js";
import PaymentTransaction from "../models/payment_transaction.model.js";
import Product from "../models/product.model.js";

// Get all discount users (Only for superAdmin)
export const getDiscountUsers = async (req, res, next) => {
    try {

        // Fetch all users with role "discount"
        const discountUsers = await User.find({ role: "discount" }).select("-password"); // Exclude passwords for security

        res.status(200).json(discountUsers);

    } catch (err) {
        console.error("Error fetching discount users:", err);
        next(err);
    }
};

export const createDiscountUser = async (req, res, next) => {
    try {
        // Check if the requester has superAdmin role
        if (req.role !== 'superAdmin') {
            return res.status(403).json({ message: "Only Super Admins can create discount users." });
        }

        // Extract companyId, shopId, and userId (who is creating the user) from request
        const { companyId, shopId, userId } = req;

        // Ensure required data is present
        if (!req.body.username || !req.body.password) {
            return res.status(400).json({ message: "All fields (username, password) are required." });
        }

        // Hash the password before saving the user
        const hash = bcrypt.hashSync(req.body.password, 5);

        // Create the discount user
        const newUser = new User({
            userId: "UserID-1", // This will be auto-generated by pre-save hook
            username: req.body.username,
            password: hash,
            role: "discount",  // Assigning the role explicitly
            createdBy: userId,  // Taken from request
        });

        await newUser.save();
        res.status(201).json({ message: "Discount user has been created successfully." });

    } catch (err) {
        console.error("Error creating discount user:", err);
        next(err);
    }
};


export const changeDiscountUserPassword = async (req, res, next) => {

    try {
        const { userId, currentPassword, newPassword } = req.body;

        // Find the user by userId and ensure they have the "discount" role
        const user = await User.findOne({ userId, role: "discount" });
        if (!user) {
            return res.status(404).json({ message: "User not found or not authorized to change password." });
        }

        // Check if the current password is correct
        const isMatch = bcrypt.compareSync(currentPassword, user.password);
        if (!isMatch) {
            return res.status(400).json({ message: "Current password is incorrect." });
        }

        // Hash the new password
        const hashedPassword = bcrypt.hashSync(newPassword, 5);
        user.password = hashedPassword;
        await user.save();

        res.status(200).json({ message: "Password changed successfully." });
    } catch (err) {
        console.error("Error changing discount user password:", err);
        next(err);
    }
};


// Verify discount authorization (password check only)
export const verifyDiscountAuthorization = async (req, res, next) => {
    try {
        const { userId, password } = req.body;

        // Find the user by userId and role
        const user = await User.findOne({ userId, role: 'discount' });

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        // Verify password
        const isPasswordValid = await bcrypt.compare(password, user.password);

        if (!isPasswordValid) {
            return res.status(401).json({ message: "Invalid password" });
        }

        // If password is valid and user is a DiscountManager, return success
        res.status(200).json({
            authorized: true,
            authorizerId: user.userId,
            authorizerName: user.name
        });

    } catch (error) {
        console.error("Error verifying discount authorization:", error);
        next(error);
    }
};



export const getDiscountReport = async (req, res, next) => {
    try {
        const { companyId, shopId } = req;

        // Get query parameters for filtering
        const {
            startDate,
            endDate,
            authorizerId,
            productId,
            minDiscountAmount,
            maxDiscountAmount,
            sellingType
        } = req.query;

        // Build filter object
        const filter = {
            discountAmount: { $gt: 0 },  // Only include records with discounts
            discountAuthorizedBy: { $ne: null }  // Ensure there's an authorizer
        };

        // Add companyId and shopId to filter if provided
        if (companyId) filter.companyId = companyId;
        if (shopId) filter.shopId = shopId;

        // Add date range filter if provided
        if (startDate || endDate) {
            filter.transactionDateTime = {};
            if (startDate) filter.transactionDateTime.$gte = new Date(startDate);
            if (endDate) {
                // Set endDate to end of day
                const endDateObj = new Date(endDate);
                endDateObj.setHours(23, 59, 59, 999);
                filter.transactionDateTime.$lte = endDateObj;
            }
        }

        // Add authorizer filter if provided
        if (authorizerId) filter.discountAuthorizedBy = authorizerId;

        // Add product filter if provided
        if (productId) filter.finishedgoodId = productId;

        // Add discount amount range filter if provided
        if (minDiscountAmount || maxDiscountAmount) {
            filter.discountAmount = filter.discountAmount || {};
            if (minDiscountAmount) filter.discountAmount.$gte = Number(minDiscountAmount);
            if (maxDiscountAmount) filter.discountAmount.$lte = Number(maxDiscountAmount);
        }

        // Add selling type filter if provided
        if (sellingType) filter.sellingType = sellingType;

        // Find all transactions matching the filter
        const discountTransactions = await FinishedGoodTransaction.find(filter)
            .sort({ transactionDateTime: -1 }); // Sort by transaction date (newest first)

        // Get unique authorizer IDs
        const authorizerIds = [...new Set(discountTransactions.map(t => t.discountAuthorizedBy))];

        // Fetch authorizer details in bulk
        const authorizers = await User.find({
            userId: { $in: authorizerIds }
        }).select('userId name');

        // Create a map of userId to user details for quick lookup
        const authorizerMap = {};
        authorizers.forEach(auth => {
            authorizerMap[auth.userId] = {
                id: auth.userId,
                name: auth.name
            };
        });

        // Get unique product IDs
        const productIds = [...new Set(discountTransactions.map(t => t.finishedgoodId))];

        // Fetch product details in bulk
        const products = await Product.find({ productId: { $in: productIds } }).select('productId name');

        // Create a map of productId to product details for quick lookup
        const productMap = {};
        products.forEach(product => {
            productMap[product.productId] = product.name;
        });

        // Format the response data as a direct array
        const discountReportList = discountTransactions.map(transaction => {
            const authorizer = authorizerMap[transaction.discountAuthorizedBy] || {
                id: transaction.discountAuthorizedBy,
                name: 'Unknown'
            };

            return {
                date: transaction.transactionDateTime,
                discountAmount: transaction.discountAmount,
                authorizer: {
                    id: authorizer.id,
                    name: authorizer.name
                },
                productId: transaction.finishedgoodId,
                productName: productMap[transaction.finishedgoodId] || 'Unknown Product', // Fetch product name
                orderNumber: transaction.OrderNo,
                sellingPrice: transaction.sellingPrice,
                companyId: transaction.companyId,
                shopId: transaction.shopId,
                sellingType: transaction.sellingType,
                quantity: transaction.finishedgoodQty,
                transactionCode: transaction.transactionCode
            };
        });

        // Return just the array directly
        res.status(200).json(discountReportList);

    } catch (err) {
        console.error("Error fetching discount report:", err);
        next(err);
    }
};


// Get service charge report
export const getServiceChargeReport = async (req, res, next) => {
    try {
        const { companyId, shopId } = req;

        // Get query parameters for filtering
        const {
            startDate,
            endDate,
            authorizerId,
            minServiceAmount,
            maxServiceAmount,
            sellingType
        } = req.query;

        // Build filter object
        const filter = {
            serviceChargeAuthorizedBy: { $ne: null }  // Ensure there's an authorizer
        };

        // Add companyId and shopId to filter if provided
        if (companyId) filter.companyId = companyId;
        if (shopId) filter.shopId = shopId;

        // Add date range filter if provided
        if (startDate || endDate) {
            filter.transactionDateTime = {};
            if (startDate) filter.transactionDateTime.$gte = new Date(startDate);
            if (endDate) {
                // Set endDate to end of day
                const endDateObj = new Date(endDate);
                endDateObj.setHours(23, 59, 59, 999);
                filter.transactionDateTime.$lte = endDateObj;
            }
        }

        // Add authorizer filter if provided
        if (authorizerId) filter.serviceChargeAuthorizedBy = authorizerId;

        // Add service amount range filter if provided
        if (minServiceAmount || maxServiceAmount) {
            filter.sellingTypeAmount = filter.sellingTypeAmount || {};
            if (minServiceAmount) filter.sellingTypeAmount.$gte = Number(minServiceAmount);
            if (maxServiceAmount) filter.sellingTypeAmount.$lte = Number(maxServiceAmount);
        }

        // Add selling type filter if provided
        if (sellingType) filter.sellingTypeID = sellingType;

        // Find all transactions matching the filter
        const serviceChargeTransactions = await PaymentTransaction.find(filter)
            .sort({ transactionDateTime: -1 }); // Sort by transaction date (newest first)

        // Get unique authorizer IDs
        const authorizerIds = [...new Set(serviceChargeTransactions.map(t => t.serviceChargeAuthorizedBy).filter(id => id))];

        // Fetch authorizer details in bulk
        const authorizers = await User.find({
            userId: { $in: authorizerIds }
        }).select('userId name');

        // Create a map of userId to user details for quick lookup
        const authorizerMap = {};
        authorizers.forEach(auth => {
            authorizerMap[auth.userId] = {
                id: auth.userId,
                name: auth.name
            };
        });

        // Format the response data as a direct array
        const serviceChargeReportList = serviceChargeTransactions.map(transaction => {
            const authorizer = authorizerMap[transaction.serviceChargeAuthorizedBy] || {
                id: transaction.serviceChargeAuthorizedBy,
                name: 'Unknown'
            };

            return {
                date: transaction.transactionDateTime,
                paymentID: transaction.paymentID,
                invoiceID: transaction.invoiceID,
                companyId: transaction.companyId,
                shopId: transaction.shopId,
                billTotal: transaction.billTotal,
                sellingTypeCharge: transaction.sellingTypeCharge,
                sellingTypeAmount: transaction.sellingTypeAmount,
                authorizer: {
                    id: authorizer.id,
                    name: authorizer.name
                },
                transactionCode: transaction.transactionCode
            };
        });

        // Return just the array directly
        res.status(200).json(serviceChargeReportList);

    } catch (err) {
        console.error("Error fetching service charge report:", err);
        next(err);
    }
};